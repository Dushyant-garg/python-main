from autogen_agentchat.agents import AssistantAgent, UserProxyAgent
from autogen_agentchat.messages import TextMessage
from autogen_agentchat.teams import RoundRobinGroupChat
from autogen_agentchat.conditions import MaxMessageTermination
from autogen_ext.models.openai import OpenAIChatCompletionClient
from typing import Dict, Tuple
import os
from pathlib import Path
from app.config import settings

class RequirementAnalyzer:
    """
    AutoGen-based agent for analyzing project requirements and generating SRDs
    """
    
    def __init__(self):
        """Initialize the RequirementAnalyzer with AutoGen agents"""
        
        # Initialize the OpenAI client
        self.model_client = OpenAIChatCompletionClient(
            model=settings.OPENAI_MODEL,
            api_key=settings.OPENAI_API_KEY,
            temperature=0.1,
        )
        
        # Create the requirement analyst agent
        self.analyst_agent = AssistantAgent(
            name="RequirementAnalyst",
            model_client=self.model_client,
            system_message=self._get_analyst_system_message(),
        )
        
        # Create the frontend specialist agent
        self.frontend_agent = AssistantAgent(
            name="FrontendSpecialist",
            model_client=self.model_client,
            system_message=self._get_frontend_system_message(),
        )
        
        # Create the backend specialist agent
        self.backend_agent = AssistantAgent(
            name="BackendSpecialist",
            model_client=self.model_client,
            system_message=self._get_backend_system_message(),
        )
    
    def _get_analyst_system_message(self) -> str:
        """Get system message for the requirement analyst"""
        return """You are the RequirementAnalyst in a 3-agent team. Your role is to analyze project documents and provide structured categorization for your teammates.

TEAM WORKFLOW:
1. YOU analyze and categorize requirements
2. FrontendSpecialist uses your analysis to create frontend SRD
3. BackendSpecialist uses your analysis to create backend SRD

YOUR TASK: Provide a clear, structured analysis that separates concerns for your specialist teammates.

FORMAT YOUR RESPONSE AS:

# REQUIREMENTS ANALYSIS BY ANALYST

## FRONTEND REQUIREMENTS
[List all client-side, UI, and user experience requirements]
- User Interface (UI) components and layouts
- User Experience (UX) workflows and interactions
- Client-side functionality and features
- Responsive design and mobile considerations
- Form inputs, validations, and user feedback
- Navigation menus, routing, and page structures
- Browser compatibility and accessibility

## BACKEND REQUIREMENTS  
[List all server-side, database, and system architecture requirements]
- Server-side business logic and algorithms
- Database design and data models
- API endpoints and data processing
- Authentication and authorization mechanisms
- Server architecture and scalability
- Integration with external services
- Background jobs and scheduled tasks

## INTEGRATION REQUIREMENTS
[List requirements that involve both frontend and backend coordination]
- API contracts and data exchange formats
- Authentication flows and security protocols
- Real-time communication requirements

Be thorough and specific so your teammates can create comprehensive SRDs."""
    
    def _get_frontend_system_message(self) -> str:
        """Get system message for the frontend specialist"""
        return """You are the FrontendSpecialist in a 3-agent team. You work AFTER the RequirementAnalyst has provided their analysis.

TEAM WORKFLOW:
1. RequirementAnalyst analyzes and categorizes requirements
2. YOU create a detailed Frontend SRD using ONLY the frontend requirements
3. BackendSpecialist will create backend SRD separately

YOUR ROLE: Take the RequirementAnalyst's categorized requirements and create a comprehensive Frontend SRD.

FOCUS EXCLUSIVELY ON:
- Client-side user interface and user experience
- Frontend frameworks and technologies  
- Browser-based functionality and performance
- User interactions and client-side workflows

FORMAT YOUR RESPONSE AS:

# Frontend Software Requirements Document
*Generated by FrontendSpecialist based on RequirementAnalyst's analysis*

## 1. Project Overview
[Brief description of frontend scope]

## 2. User Interface Requirements  
[Detailed UI specifications based on analyst's frontend requirements]

## 3. User Experience Requirements
[UX workflows and interaction patterns]

## 4. Client-Side Functionality
[JavaScript behavior and frontend logic]

## 5. Technology Stack
[Frontend frameworks, libraries, and tools]

## 6. Performance Requirements
[Client-side performance targets]

## 7. Integration Points
[How frontend will consume APIs - client perspective only]

CRITICAL: Only use requirements marked as "FRONTEND" by the RequirementAnalyst. Do NOT create backend specifications."""
    
    def _get_backend_system_message(self) -> str:
        """Get system message for the backend specialist"""
        return """You are the BackendSpecialist in a 3-agent team. You work AFTER the RequirementAnalyst and FrontendSpecialist.

TEAM WORKFLOW:
1. RequirementAnalyst analyzes and categorizes requirements  
2. FrontendSpecialist creates frontend SRD
3. YOU create a detailed Backend SRD using ONLY the backend requirements

YOUR ROLE: Take the RequirementAnalyst's categorized requirements and create a comprehensive Backend SRD.

FOCUS EXCLUSIVELY ON:
- Server-side business logic and algorithms
- Database design and data persistence  
- API development and web services
- Authentication and authorization systems
- Server infrastructure and deployment
- Data processing and background jobs

FORMAT YOUR RESPONSE AS:

# Backend Software Requirements Document
*Generated by BackendSpecialist based on RequirementAnalyst's analysis*

## 1. System Architecture
[Server architecture and design patterns]

## 2. Database Requirements
[Database design, schemas, and data models]

## 3. API Specifications  
[REST API endpoints and web service definitions]

## 4. Business Logic Requirements
[Core business rules and server-side algorithms]

## 5. Authentication & Authorization
[Security systems and access control]

## 6. Performance & Scalability
[Server performance and scaling requirements]

## 7. Infrastructure & DevOps
[Deployment, monitoring, and operations]

## 8. Integration Requirements
[Third-party services and external APIs]

CRITICAL: Only use requirements marked as "BACKEND" by the RequirementAnalyst. Do NOT include UI, frontend, or client-side specifications."""
    
    async def analyze_requirements(self, document_text: str) -> Dict[str, str]:
        """
        Analyze document text and generate frontend and backend SRDs using multi-agent collaboration
        
        Args:
            document_text: The parsed text from the uploaded document
            
        Returns:
            Dictionary containing 'frontend_srd' and 'backend_srd' content
        """
        
        # Create initial task for the multi-agent team
        initial_task = f"""
        Team Task: Analyze the following project document and create two comprehensive Software Requirements Documents.

        PROJECT DOCUMENT:
        {document_text}

        WORKFLOW:
        1. RequirementAnalyst: First analyze and categorize all requirements into frontend, backend, and integration sections
        2. FrontendSpecialist: Use the analysis to create a detailed Frontend SRD focusing ONLY on client-side requirements
        3. BackendSpecialist: Use the analysis to create a detailed Backend SRD focusing ONLY on server-side requirements

        Each agent should build upon the previous agent's work while staying strictly within their domain expertise.
        
        RequirementAnalyst: Start by providing your structured analysis.
        """
        
        # Create a multi-agent team with all three agents
        team = RoundRobinGroupChat(
            participants=[self.analyst_agent, self.frontend_agent, self.backend_agent],
            termination_condition=MaxMessageTermination(6)  # Allow 2 messages per agent
        )
        
        # Run the multi-agent conversation
        task_message = TextMessage(content=initial_task, source="user")
        result = await team.run(task=task_message)
        
        # Extract the different outputs from the conversation
        messages = result.messages
        
        # Find the analyst's analysis (should be first agent response)
        analysis_content = ""
        frontend_srd = ""
        backend_srd = ""
        
        for i, message in enumerate(messages):
            if hasattr(message, 'source') and message.source == "RequirementAnalyst":
                analysis_content = message.content
            elif hasattr(message, 'source') and message.source == "FrontendSpecialist":
                # Look for the most complete frontend response
                if "Frontend Software Requirements Document" in message.content or "# Frontend" in message.content:
                    frontend_srd = message.content
            elif hasattr(message, 'source') and message.source == "BackendSpecialist":
                # Look for the most complete backend response
                if "Backend Software Requirements Document" in message.content or "# Backend" in message.content:
                    backend_srd = message.content
        
        # Fallback: if agents didn't identify properly, use message order
        if not analysis_content or not frontend_srd or not backend_srd:
            agent_messages = [msg for msg in messages if hasattr(msg, 'source') and msg.source != "user"]
            if len(agent_messages) >= 3:
                analysis_content = agent_messages[0].content if not analysis_content else analysis_content
                frontend_srd = agent_messages[1].content if not frontend_srd else frontend_srd
                backend_srd = agent_messages[2].content if not backend_srd else backend_srd
        
        # Additional fallback: extract from message content patterns
        if not frontend_srd or not backend_srd:
            for message in messages:
                content = message.content
                if "frontend" in content.lower() and ("ui" in content.lower() or "interface" in content.lower()):
                    if len(content) > len(frontend_srd):
                        frontend_srd = content
                elif "backend" in content.lower() and ("database" in content.lower() or "server" in content.lower()):
                    if len(content) > len(backend_srd):
                        backend_srd = content
        
        return {
            "frontend_srd": frontend_srd,
            "backend_srd": backend_srd,
            "analysis": analysis_content,
            "full_conversation": [msg.content for msg in messages if hasattr(msg, 'content')]
        }
    
    async def save_srds(self, srd_content: Dict[str, str], output_dir: str = "output") -> Tuple[str, str]:
        """
        Save the generated SRDs to markdown files
        
        Args:
            srd_content: Dictionary containing SRD content
            output_dir: Directory to save the files
            
        Returns:
            Tuple of (frontend_file_path, backend_file_path)
        """
        
        # Create output directory if it doesn't exist
        Path(output_dir).mkdir(exist_ok=True)
        
        # Save frontend SRD
        frontend_path = os.path.join(output_dir, "srd_frontend.md")
        with open(frontend_path, 'w', encoding='utf-8') as f:
            f.write(srd_content["frontend_srd"])
        
        # Save backend SRD
        backend_path = os.path.join(output_dir, "srd_backend.md")
        with open(backend_path, 'w', encoding='utf-8') as f:
            f.write(srd_content["backend_srd"])
        
        return frontend_path, backend_path